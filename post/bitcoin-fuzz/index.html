<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Fuzzing Evolution: How developers make Bitcoin more secure - chinggg的博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chinggg" /><meta name="description" content="Abstract Bitcoin is a widely used distributed system that is time-tested and recognized to be secure. However, most of the existing research focus on its theoretical security model, while ignoring the possible vulnerabilities in its software implementation. This paper will review how fuzzing, an increasingly popular automated vulnerability detection method, has been used in practice and refined stage by stage by Bitcoin Core developers. In addition, this paper will describe recent work published in ICSE 2022 that analyzes three different software testing techniques and summarizes their practical effects when applied to Bitcoin Core." /><meta name="keywords" content="chinggg, blog" />


<meta name="baidu-site-verification" content="chinggg" />
<meta name="google-site-verification" content="R-pe5fMn8y2i91GFmYpudXwbv7bMLv4XYoHqLWB3Y9I" />


<meta name="generator" content="Hugo 0.80.0 with theme even" />


<link rel="canonical" href="https://chinggg.github.io/post/bitcoin-fuzz/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.299b56866ca7e5e86584d6353e1e1a12be9d049f05d134ced7e689b415569dc5.css" rel="stylesheet">





<meta property="og:title" content="Fuzzing Evolution: How developers make Bitcoin more secure" />
<meta property="og:description" content="Abstract Bitcoin is a widely used distributed system that is time-tested and recognized to be secure. However, most of the existing research focus on its theoretical security model, while ignoring the possible vulnerabilities in its software implementation. This paper will review how fuzzing, an increasingly popular automated vulnerability detection method, has been used in practice and refined stage by stage by Bitcoin Core developers. In addition, this paper will describe recent work published in ICSE 2022 that analyzes three different software testing techniques and summarizes their practical effects when applied to Bitcoin Core." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chinggg.github.io/post/bitcoin-fuzz/" />
<meta property="article:published_time" content="2022-05-13T21:20:48+08:00" />
<meta property="article:modified_time" content="2022-06-01T09:32:34+08:00" />
<meta itemprop="name" content="Fuzzing Evolution: How developers make Bitcoin more secure">
<meta itemprop="description" content="Abstract Bitcoin is a widely used distributed system that is time-tested and recognized to be secure. However, most of the existing research focus on its theoretical security model, while ignoring the possible vulnerabilities in its software implementation. This paper will review how fuzzing, an increasingly popular automated vulnerability detection method, has been used in practice and refined stage by stage by Bitcoin Core developers. In addition, this paper will describe recent work published in ICSE 2022 that analyzes three different software testing techniques and summarizes their practical effects when applied to Bitcoin Core.">
<meta itemprop="datePublished" content="2022-05-13T21:20:48+08:00" />
<meta itemprop="dateModified" content="2022-06-01T09:32:34+08:00" />
<meta itemprop="wordCount" content="4067">



<meta itemprop="keywords" content="Paper,Bitcoin,Fuzzing," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fuzzing Evolution: How developers make Bitcoin more secure"/>
<meta name="twitter:description" content="Abstract Bitcoin is a widely used distributed system that is time-tested and recognized to be secure. However, most of the existing research focus on its theoretical security model, while ignoring the possible vulnerabilities in its software implementation. This paper will review how fuzzing, an increasingly popular automated vulnerability detection method, has been used in practice and refined stage by stage by Bitcoin Core developers. In addition, this paper will describe recent work published in ICSE 2022 that analyzes three different software testing techniques and summarizes their practical effects when applied to Bitcoin Core."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chinggg的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/links/">
        <li class="mobile-menu-item">链接</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/ranking/">
        <li class="mobile-menu-item">排行</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">搜索</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">chinggg的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/links/">链接</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ranking/">排行</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">搜索</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Fuzzing Evolution: How developers make Bitcoin more secure</h1>

      <div class="post-meta">
        <span class="post-time" title="2022-05-13 21:20:48 &#43;0800 &#43;0800"> 2022-05-13 </span>
        <div class="post-category">
            <a href="/categories/research/"> Research </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#abstract">Abstract</a></li>
        <li><a href="#intro">Intro</a></li>
        <li><a href="#background">Background</a>
          <ul>
            <li><a href="#coverage-guided-fuzzing">Coverage-guided Fuzzing</a></li>
            <li><a href="#continuous-fuzzing-and-oss-fuzz">Continuous Fuzzing and OSS-Fuzz</a></li>
          </ul>
        </li>
        <li><a href="#bitcoin-fuzzing-infrastructure">Bitcoin Fuzzing Infrastructure</a>
          <ul>
            <li><a href="#history">History</a>
              <ul>
                <li><a href="#stage-1-proof-of-concept-2013-2016">Stage 1: Proof of Concept (2013-2016)</a></li>
                <li><a href="#stage-2-standardized-fuzzing-2017---2018">Stage 2: Standardized Fuzzing (2017 - 2018)</a></li>
                <li><a href="#stage-3-scaling-with-the-community-2019-2020">Stage 3: Scaling with the community (2019-2020)</a></li>
                <li><a href="#stage-4-embracing-oss-fuzz-2021---present">Stage 4: Embracing OSS-Fuzz (2021 - Present)</a></li>
              </ul>
            </li>
            <li><a href="#case-study-of-fuzz-target-process_message">Case Study of Fuzz Target <code>process_message</code></a></li>
            <li><a href="#fuzz-trophies">Fuzz Trophies</a></li>
          </ul>
        </li>
        <li><a href="#software-testing-techniques-to-improve-fuzzing">Software Testing Techniques To Improve Fuzzing</a>
          <ul>
            <li><a href="#enhancing-diversity-by-ensemble-fuzzing">Enhancing Diversity by Ensemble fuzzing</a></li>
            <li><a href="#increasing-variance-by-swarm-fuzzing">Increasing Variance by Swarm Fuzzing</a></li>
            <li><a href="#oracle-problem-and-mutation-testing">Oracle Problem and Mutation Testing</a></li>
          </ul>
        </li>
        <li><a href="#conclusion-and-future-work">Conclusion and Future Work</a></li>
        <li><a href="#acknowledgements">Acknowledgements</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="abstract">Abstract</h2>
<p>Bitcoin is a widely used distributed system that is time-tested and recognized to be secure. However, most of the existing research focus on its theoretical security model, while ignoring the possible vulnerabilities in its software implementation. This paper will review how fuzzing, an increasingly popular automated vulnerability detection method, has been used in practice and refined stage by stage by Bitcoin Core developers. In addition, this paper will describe recent work published in ICSE 2022 that analyzes three different software testing techniques and summarizes their practical effects when applied to Bitcoin Core.</p>
<p><strong>Keywords</strong>: fuzzing, software testing, Bitcoin</p>
<h2 id="intro">Intro</h2>
<p>Bitcoin is one of the most prominent distributed software systems in the world, and a key part of a potentially revolutionary new form of decentralized financial (DeFi) tool, cryptocurrency. Due to its distributed nature, Bitcoin in some sense is the sum of the operations of the code executed by many independent nodes rather than the original software created by Satoshi Nakamoto. There are several different implementations of Bitcoin written in various programming languages, like <a href="https://github.com/btcsuite/btcd" target="_blank">btcd</a>, <a href="https://github.com/bcoin-org/bcoin" target="_blank">bcoin,</a> and <a href="https://github.com/bitcoin-s/bitcoin-s" target="_blank">bitcoin-s</a>. However, Bitcoin Core, written in C++, is the <em>reference implementation</em> of the Bitcoin system, meaning that it is the authoritative reference on how each part of the technology should be implemented. To a significant degree, the code of Bitcoin Core is Bitcoin, so we may mix these two terms in this paper. The main Bitcoin Core repo on GitHub has over 64,000 stars and has been forked more than 32,000 times.</p>
<p>Because of Bitcoin&rsquo;s fame and the high monetary value, the Bitcoin protocol and its implementations are a high-value target for hackers. Though many works have been done to analyze the security model of Bitcoin, most of them focused on theory but ignore software implementation. This paper will describe how Bitcoin Core, as a popular open-source software (OSS), uses fuzzing to secure its codebase against potential vulnerabilities. Our main contributions are:</p>
<ul>
<li>We present the first insight into the long-term evolution of Bitcoin Core&rsquo;s fuzzing infrastructure by investigating every footprint left by developers on GitHub</li>
<li>We describe the survey presented at ICSE 2022 about different software testing techniques and how they improve Bitcoin&rsquo;s fuzzing effect</li>
</ul>
<h2 id="background">Background</h2>
<p>Among the many software testing techniques available today, fuzzing has remained highly popular due to its conceptual simplicity, its low barrier to deployment, and its vast amount of empirical evidence in discovering real-world software vulnerabilities. At a high level, fuzzing refers to a process of repeatedly running a program with generated inputs that may be syntactically or semantically malformed. It is necessary to provide background on coverage-guided fuzzing and OSS-Fuzz.</p>
<h3 id="coverage-guided-fuzzing">Coverage-guided Fuzzing</h3>
<p>Coverage-guided fuzzing (CGF), implemented by tools such as AFL, libFuzzer, and honggfuzz, is a popular bug detection method. CGF uses genetic search to find inputs that maximize code coverage. Algorithm 1 describes CGF at a high level. The algorithm maintains a pool of <em>Inputs</em> and the <em>TotalCoverage</em> of program $p$ on Inputs. The user provides seed inputs to instantiate <em>Inputs</em>. The fuzzer repeatedly picks an input $i$ from the pool of Inputs and applies a mutation (e.g., increment, bit flip, or user-defined mutations) to produce $i′$. The fuzzer then executes program $p$ on mutated input $i′$ to gather the coverage of program $p$ on $i′$ and detect any error, such as crashes, assertion violations, timeouts, memory leaks, etc.  If $i′$ does not trigger an error and discovers new coverage that is not previously seen in <em>TotalCoverage</em>, then add $i′$ to <em>Inputs</em> and update <em>TotalCoverage</em>. By finding inputs that cover new code, CGF aims to test as much of the program as possible.</p>
<p><img src="/post_img/Bitcoin-Fuzz/cov-fuzz-algo.png" alt=""></p>
<p>Fuzzers need an entrypoint into the program to provide test inputs; such an entrypoint is often called a fuzz target. libFuzzer-style fuzz targets — which AFL and honggfuzz also support and OSS-Fuzz uses — are functions that take in fuzzer-generated arbitrary bytestream input, transform the input to program-usable input data if needed, and execute the program under test with the input.</p>
<h3 id="continuous-fuzzing-and-oss-fuzz">Continuous Fuzzing and OSS-Fuzz</h3>
<p>Continuous fuzzing uses fuzzing as part of a continuous testing strategy to find regressions as software evolves. Several organizations incorporate fuzzing as part of their quality assurance strategy or offer tools that provide continuous fuzzing as a service.</p>
<p>OSS-Fuzz is Google’s continuous fuzzing service for open source software projects, which combines modern fuzzing techniques with scalable, distributed execution. OSS-Fuzz uses ClusterFuzz, Google’s scalable fuzzing infrastructure as its back-end. Figure 1 illustrates OSS-Fuzz’s workflow. Developers in a participating OSS project write fuzz targets and provide instructions for building the software. OSS-Fuzz continuously builds the software and uploads it to ClusterFuzz. ClusterFuzz finds fuzz targets and uses the coverage-guided fuzzers AFL, libFuzzer, and honggfuzz to fuzz the software. Upon detecting a bug, ClusterFuzz checks whether the bug is a duplicate of any previously found bugs, minimizes the bug inducing input, and bisects the range of commits in which the regression occurred. If the bug is not a duplicate, then ClusterFuzz files a bug report on Monorail, an issue tracker. ClusterFuzz periodically verifies whether any previously found bugs are fixed; if so, OSS-Fuzz updates fixed bugs’ report.</p>
<p><img src="https://github.com/google/oss-fuzz/raw/master/docs/images/process.png" alt=""></p>
<h2 id="bitcoin-fuzzing-infrastructure">Bitcoin Fuzzing Infrastructure</h2>
<h3 id="history">History</h3>
<p><img src="/post_img/Bitcoin-Fuzz/timeline.png" alt=""></p>
<h4 id="stage-1-proof-of-concept-2013-2016">Stage 1: Proof of Concept (2013-2016)</h4>
<p>Neither Bitcoin nor fuzzing has a long history. The first piece of code about fuzzing was introduced by <a href="https://github.com/gavinandresen" target="_blank">Gavin Andresen</a> in <a href="https://github.com/bitcoin/bitcoin/pull/3173" target="_blank">PR#3173</a>, which just added a simple protected method in the <code>CNode</code> class. All it can do is randomly corrupt 1-of-N sent messages. It was understandably primitive, since AFL, the widely-used generic fuzzer, does not even exist until 2 months later in 2013.</p>
<p>Three years later in 2016, <a href="https://github.com/pstratem" target="_blank">Patrick Strateman</a> first attempted to bring a simple fuzzing framework to Bitcoin in <a href="https://github.com/bitcoin/bitcoin/pull/7940" target="_blank">PR#7940</a>, but he did not make the code merged. Luckily, <a href="https://github.com/laanwj" target="_blank">laawj</a> resurrect pstratem&rsquo;s fuzzing framework as part of Bitcoin&rsquo;s test code in <a href="https://github.com/bitcoin/bitcoin/pull/9172" target="_blank">PR#9172</a>. This simple fuzzing framework test deserialization by reading input from <code>stdin</code>, which makes it compatible with AFL.</p>
<h4 id="stage-2-standardized-fuzzing-2017---2018">Stage 2: Standardized Fuzzing (2017 - 2018)</h4>
<p>In May 2017, Google announced rewards for open source projects that integrate fuzz targets into OSS-Fuzz. As a quick response, contributor <a href="https://github.com/practicalswift" target="_blank">practicalswift</a> proposed making Bitcoin ready for it in <a href="https://github.com/bitcoin/bitcoin/issues/10364" target="_blank">Issue#10364</a>, where developers made lots of discussions. He also added two more tests for deserialization routines used by <code>ProcessMessage</code> in <a href="https://github.com/bitcoin/bitcoin/pull/10409" target="_blank">PR#10409</a>, brought libFuzzer support in <a href="https://github.com/bitcoin/bitcoin/pull/10440" target="_blank">PR#10440</a>, and made fuzzing ~200x faster by enabling AFL&rsquo;s deferred forkserver and persistent mode in <a href="https://github.com/bitcoin/bitcoin/pull/10415" target="_blank">PR#10415</a>. Thanks to his efforts, Bitcoin has made big progress in setting up fuzz testing suites, but that is still not enough for production due to low code coverage. Besides, OSS-Fuzz&rsquo;s policy about short bug disclosure period is not agreed upon by all members.</p>
<p>Another interesting thing that happened in 2017 is that <a href="https://github.com/guidovranken" target="_blank">Guido Vranken</a>, known for <a href="https://github.com/guidovranken/cryptofuzz" target="_blank">fuzzing cryptographic libraries</a>, offered his <a href="https://github.com/guidovranken/bitcoin/tree/fuzzing/fuzzers" target="_blank">13 different fuzzers</a> implemented as libFuzzer fuzz targets in <a href="https://github.com/bitcoin/bitcoin/issues/11045" target="_blank">Issue#11045</a>. However, the existing simple fuzzer of Bitcoin is just a single binary that decides on the first few bits of the buffer what target to pick. This ineffective approach of switching between tests based on input is criticized for confusing the fuzzer with unnecessary re-use of fuzzing inputs, making it quite hard to see which fuzzers are still hitting new paths. It was not until Jan 2019 that <a href="https://github.com/MarcoFalke" target="_blank">MarcoFalke</a> managed to build fuzz targets into separate executables in <a href="https://github.com/bitcoin/bitcoin/pull/15043" target="_blank">PR#15043</a> by using different C preprocessor macros. He also renamed  <code>test/fuzz/test_bitcoin_fuzzy.cpp</code> to <code>test/fuzz/deserialize.cpp</code> in <a href="https://github.com/bitcoin/bitcoin/pull/15399" target="_blank">PR#15399</a>, which allows more fuzz targets that test different parts of Bitcoin code to be added in the future.</p>
<h4 id="stage-3-scaling-with-the-community-2019-2020">Stage 3: Scaling with the community (2019-2020)</h4>
<p>2019 witnessed huge growth of Bitcoin&rsquo;s fuzzing infrastructure. To make fuzzing easily integrated with CI tests, <a href="https://github.com/MarcoFalke" target="_blank">MarcoFalke</a> added <em>test_runner.py</em>, a script which is still used now, in <a href="https://github.com/bitcoin/bitcoin/pull/15295" target="_blank">PR#15295</a>. He also simplified Makefile in <a href="https://github.com/bitcoin/bitcoin/pull/15504" target="_blank">PR#15504</a> by linking against <code>BasicTestingSetup</code>, which was shared with unit tests. After that, <a href="https://github.com/practicalswift" target="_blank">practicalswift</a> and he made lots of contribution to add more fuzzing harness for other part of Bitcoin&rsquo;s code, of which <a href="https://github.com/bitcoin/bitcoin/pull/17009/" target="_blank">PR#17009</a> is the first newly added fuzz harness.</p>
<p>The increased number of fuzz targets also brings several downsides as discussed in <a href="https://github.com/bitcoin/bitcoin/issues/20088" target="_blank">Issue#20088</a>. Having many targets not only slowing down build process with coslty disk space and CPU time, but also makes writing new fuzz tests unnecessarily hard. In Decemeber 2020, <a href="https://github.com/MarcoFalke" target="_blank">MarcoFalke</a> made a huge refactoring with change of 100 files to link all targets once in <a href="https://github.com/bitcoin/bitcoin/pull/20560" target="_blank">PR#20560</a>. By specifying environment variables, different fuzz targets can bde executed using only one binary. He proved that the single binary approach does not effect the fuzzing performance by showing benchmark results. So the basic architecture has not changed since then.</p>
<h4 id="stage-4-embracing-oss-fuzz-2021---present">Stage 4: Embracing OSS-Fuzz (2021 - Present)</h4>
<p>In May 2021, Bitcoin Core made its <a href="https://github.com/google/oss-fuzz/pull/5699" target="_blank">initial integration</a> into OSS-Fuzz. Till May 2022, <a href="https://github.com/google/oss-fuzz/pulls?q=is%3Apr&#43;bitcoin&#43;is%3Aclosed" target="_blank">34 pull requests</a> have been submitted to OSS-Fuzz for further improvement.</p>
<p>As Bitcoin Core participates in Google&rsquo;s <a href="https://github.com/google/oss-fuzz/tree/master/projects/bitcoin-core" target="_blank">OSS-Fuzz</a> program, there is a dashboard of <a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?q=bitcoin-core" target="_blank">publicly disclosed vulnerabilities</a>. Generally, vulnerabilities are disclosed as soon as possible after they are fixed to give users the knowledge they need to be protected. However, because Bitcoin is a live P2P network, and not just standalone local software, not every issue may be disclosed within Google&rsquo;s standard <a href="https://google.github.io/oss-fuzz/getting-started/bug-disclosure-guidelines/" target="_blank">90-day disclosure window</a> if a partial or delayed disclosure is important to protect users or the function of the network.</p>
<p>By reviewing the history of Bitcoin&rsquo;s fuzzing evolution, we can learn that it is not easy for Bitcoin, which is probably the most running distributed software in the world, to build its fuzzing infrastructure and integrate with OSS-Fuzz. Maintainers have to take many factors into consideration before accepting code changes.</p>
<h3 id="case-study-of-fuzz-target-process_message">Case Study of Fuzz Target <code>process_message</code></h3>
<p>Fuzz target <code>process_message</code> is introduced in <a href="https://github.com/bitcoin/bitcoin/pull/17989" target="_blank">PR#17989</a>, which enables high-level fuzzing of the P2P layer. All code paths reachable from this fuzzer can be assumed to be reachable for an untrusted peer so it worth taking a look at.</p>
<p>To achieve optimal results when using coverage-guided fuzzing, there are both one general fuzzing binary (<code>process_message</code>) which handles all messages types and specialized fuzzing binaries per message type (<code>process_message_addr</code>, <code>process_message_block</code>, <code>process_message_blocktxn </code>, etc.) The reason to have all message types in one fuzzers is to allow auto-detection bring auto-detection and thus fuzzing of newly introduced messages types without updating the fuzzer. The reason to have also have per-message-type fuzzers is largely for the same reason that we have one fuzzing binary per deserialization: to make it relatively easier for coverage guided fuzzers to reach deep.</p>
<pre><code class="language-cpp">void fuzz_target(FuzzBufferType buffer, const std::string&amp; LIMIT_TO_MESSAGE_TYPE)
{
    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());

    ConnmanTestMsg&amp; connman = *static_cast&lt;ConnmanTestMsg*&gt;(g_setup-&gt;m_node.connman.get());
    TestChainState&amp; chainstate = *static_cast&lt;TestChainState*&gt;(&amp;g_setup-&gt;m_node.chainman-&gt;ActiveChainstate());
    SetMockTime(1610000000); // any time to successfully reset ibd
    chainstate.ResetIbd();

    const std::string random_message_type{fuzzed_data_provider.ConsumeBytesAsString(CMessageHeader::COMMAND_SIZE).c_str()};
    if (!LIMIT_TO_MESSAGE_TYPE.empty() &amp;&amp; random_message_type != LIMIT_TO_MESSAGE_TYPE) {
        return;
    }
    CNode&amp; p2p_node = *ConsumeNodeAsUniquePtr(fuzzed_data_provider).release();

    connman.AddTestNode(p2p_node);
    g_setup-&gt;m_node.peerman-&gt;InitializeNode(&amp;p2p_node);
    FillNode(fuzzed_data_provider, connman, *g_setup-&gt;m_node.peerman, p2p_node);

    const auto mock_time = ConsumeTime(fuzzed_data_provider);
    SetMockTime(mock_time);

    // fuzzed_data_provider is fully consumed after this call, don't use it
    CDataStream random_bytes_data_stream{fuzzed_data_provider.ConsumeRemainingBytes&lt;unsigned char&gt;(), SER_NETWORK, PROTOCOL_VERSION};
    try {
        g_setup-&gt;m_node.peerman-&gt;ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream,
                                                GetTime&lt;std::chrono::microseconds&gt;(), std::atomic&lt;bool&gt;{false});
    } catch (const std::ios_base::failure&amp;) {
    }
    {
        LOCK(p2p_node.cs_sendProcessing);
        g_setup-&gt;m_node.peerman-&gt;SendMessages(&amp;p2p_node);
    }
    SyncWithValidationInterfaceQueue();
    g_setup-&gt;m_node.connman-&gt;StopNodes();
}
</code></pre>
<p>The basic idea is simple:</p>
<ul>
<li>On initialization, create a few blocks</li>
<li>On each input, create a few random network peers</li>
<li>Then receive random messages from those random peers</li>
</ul>
<h3 id="fuzz-trophies">Fuzz Trophies</h3>
<p>A collection of bugs found by developers via fuzzing can be found at <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Fuzz-Trophies">https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Fuzz-Trophies</a>. Some of them are actually exploitable vulnerabilities. For instance, <a href="https://nvd.nist.gov/vuln/detail/CVE-2017-18350" target="_blank">CVE-2017-18350</a> is a buffer overflow vulnerability which allows a malicious SOCKS proxy server to overwrite the program stack on systems with a signed  <code>char</code> type (including common 32-bit and 64-bit x86 PCs). The vulnerability was introduced in 2012 and kept unknown until practicalswift used fuzzing to find it and disclosed it to security team in 2017. <a href="https://github.com/bitcoin/bitcoin/pull/19203/" target="_blank">PR#19203</a> added a regression fuzz harness for it.</p>
<h2 id="software-testing-techniques-to-improve-fuzzing">Software Testing Techniques To Improve Fuzzing</h2>
<p>Although Bitcoin Core has put much effort into fuzzing, it seemed that the fuzzing was stuck: neither code coverage nor found bugs were increasing with additional fuzzing time. This is a common phenomenon called <em><strong>saturation</strong></em> when fuzzing software. That is, at first a particular fuzzer applied to a system will tend to continuously increase both coverage and discovery of previously-unknown bugs. But, at some point, the number of new bugs found by the fuzzer drops off, eventually approaching zero.</p>
<p>The underlying reason for saturation is that any fuzzer can explore a space of generated tests determined by a complex probability distribution. Some bugs lie in the high-probability portion of this space, and other bugs lie in very low probability or even zero probability parts of the space.</p>
<p>Groce, Alex, et al. present their work <em>Looking for Lacunae in Bitcoin Core&rsquo;s Fuzzing Efforts</em> at ICSE 2022, which describes how researchers of <a href="https://chaincode.com/" target="_blank">Chaincode Labs</a> applied various kinds of techniques to solve the problem. This section is a paraphrase of their work.</p>
<h3 id="enhancing-diversity-by-ensemble-fuzzing">Enhancing Diversity by Ensemble fuzzing</h3>
<p>Ensemble fuzzing is an approach that recognizes the need for diverse methods for test generation, at least in the context of fuzzing; using multiple fuzzers to seed each other and avoid saturation is a core motivation for ensemble fuzzing. Inspired by ensemble methods in machine learning, ensemble fuzzing runs multiple fuzzers, and uses inputs generated by each fuzzer to seed the other fuzzers.</p>
<p>Note that in one important sense Bitcoin Core is using ensemble fuzzing, in that OSS-Fuzz runs multiple fuzzers, including libFuzzer, AFL, and Honggfuzz) with different compilation flags and sanitizers. Additionally, the Bitcoin Core team has servers running different fuzzers. All of these are coordinated via the qa-assets repository to which our Eclipser-based tests were added. This is, however, a more manual and less controlled process than true ensemble cross-seeding on-the-fly during a fuzzing campaign, and there are suggestions that a well-chosen coordination strategy can significantly improve ensemble effectiveness.</p>
<h3 id="increasing-variance-by-swarm-fuzzing">Increasing Variance by Swarm Fuzzing</h3>
<p>Swarm testing is a method for improving test generation that relies on identifying <em>features</em> of tests, and disabling some of the features in each test. For instance, if features are API calls, and we are testing a stack with <code>push</code>, <code>pop</code>, <code>top</code>, and <code>clear</code> calls, a non-swarm random test of any significant length will contain multiple calls to all of the functions. In swarm testing, however, for each test some of the calls (with a certain probability for each call) will be disabled, but different calls will be disabled for each generated test. This produces less variance between calls <em>within</em> tests, but much more variance <em>between</em> tests. Practically, in the stack example, it will enable the size of the stack to grow much larger than it ever would have any chance of doing in non-swarm testing, due to some tests omitting <code>pop</code> and/or <code>clear</code> calls.</p>
<p><img src="https://howtotestit.files.wordpress.com/2021/07/swarm.png" alt=""></p>
<p>The picture above shows the basic logic of <a href="https://agroce.github.io/issta12.pdf" target="_blank">swarm testing</a>. There is a 1,000×1,000 array of pixels, where each 10×10 block represents a sequence of 100 function calls in an API sequence test. Each pixel is a call to a function, and the calls to five different functions are coded by color (black, white, red, green, and blue).</p>
<p>The top half of the figure is what traditional sequence generation will tend to do in such a setting, assuming each call is given equal probability: every test will look like every other test. The details will vary, but at a certain level the arrangement will be very homogeneous; in fact, the eye can’t tell where one test ends and another begins! Let’s call this the kitchen-sink approach to testing: every test generated throws in everything it can, at least potentially.</p>
<p>The bottom half of the figure represents <em>swarm testing</em>. In swarm testing, function calls in each test are not always included but potentially picked with a probability. On average, the diversity between calls within each test is <em>much worse</em> for the swarm portion of the testing. However, it is easy to tell tests apart, with practical consequences. Behind the visually obvious impact of swarm testing, there is simple statistical reality. While it is <em>possible</em> for a single method to be called 100 times using the kitchen-sink approach, the most instances of any single call we observed was 37. For the swarm tests, of course, each method was called more than 50 times (and in fact 100 times) in multiple tests.</p>
<p>Swarm testing probably works because most coverage targets, and most bugs, likely rely on including some test features (e.g., function calls), which can be designated <em>triggers</em>, but also are <em>prevented</em> by other function calls (designated <em>suppressors</em>).</p>
<p>In <a href="https://github.com/bitcoin/bitcoin/issues/22628" target="_blank">Issue#22628</a>, Alex Groce tried swarm fuzzing on fuzz target <code>process_messages</code> for four weeks but he found the new coverage generated was minimal. Because there is a fuzz target <code>process_message</code> which only generate one type of message when running. The ability to run <code>process_message</code> with a single message type and the frequent introduction of the resulting inputs into <code>process_messages</code> (and the generic, unconstrained <code>process_message</code> fuzzing) probably, in a less automated way, also achieves many of the benefits of swarm testing itself: mixing complex lengthy runs of a single type or mix of types. It does show that some advanced fuzzing strategies can be anticipated by particularly savvy and capable fuzz engineers, willing to directly use raw fuzzing data, and write tools to support that kind of low-level hand-tuning of fuzz corpuses.</p>
<h3 id="oracle-problem-and-mutation-testing">Oracle Problem and Mutation Testing</h3>
<p>Many efforts have been done to generate various test input that could reach more code. However, sometimes code coverage is already high enough and no bugs could be found because fuzzers actually know nothing about correctness. What is a bug? That is the question to fuzzers.</p>
<p>The only kind of bug that can be found easily without additional work is program crash, which is also the only behavior that AFL considers to be a bug. But programs can do bad things other than crash. For instance, a hello-world program will never crash, but it always fail to do the expected jobs.</p>
<p>In software testing, we use <em><strong>oracle</strong></em> to describe a source of insight into whether a program run did what it was supposed to do. The general term for a way to decide if a particular execution of a program is “good” or “bad” (if a test fails or passes, for example) is <strong>oracle</strong>.</p>
<p>Adding <em>assert</em> statements is one well-established way to make programs have oracle power. An assert just checks that something that <em>ought</em> to be true at runtime <em>is true</em>, and crashes the program if it isn’t. Another way to get more crashes automatically is to compile a program with a sanitizer. For example when using clang, adding <code>-fsanitize=address</code> will make the program crash if it performs a variety of unsafe memory operations that might otherwise not cause a problem, or at least not an obvious problem leading to a crash.</p>
<p>Mutation testing, compared with coverage, can provide more valuable information on oracle power. The basic idea of mutation testing is very simple: add new fake bugs by making small changes to the program then grade the testing effort according to how many bugs can be found.</p>
<p>To perform mutation analysis on Bitcoin, researchers generated mutations for code in the <code>tx_verify.cpp</code> file. Fuzzing covers 96 of 98 lines of code, 8 of 8 functions, and 74 of 102 branches for this file, guaranteeing that mutation testing will not primarily reflect missing coverage. Comparing coverage to that for functional testing, the fuzz testing has very slightly lower branch coverage, but the numbers are almost identical (72.5% vs. 73%), and the fuzz testing covers different branches than the functional testing. The missing lines are different for functional and fuzz testing as well. Figure 2 summarizes mutation analysis of the file <code>tx_verify.cpp</code>, which is critical to checking transactions for correctness.</p>
<p><img src="/post_img/Bitcoin-Fuzz/mutation-kills.png" alt=""></p>
<p>Fuzzing adds only two unique mutant kills beyond those produced by the functional testing. This raises the question: why fuzz if we already have functional tests with high code coverage? The answer lies in the fact that, even in the presence of such high-quality tests, fuzzing uncovers subtle bugs that functional tests designed by humans will almost never detect, e.g. <a href="https://github.com/bitcoin/bitcoin/issues/22450">https://github.com/bitcoin/bitcoin/issues/22450</a>. A major purpose of fuzzing is to address limits in more traditional functional testing, where known inputs are paired with expected behavior. While functional or unit testing is very powerful, the kinds of bugs found in vulnerabilities often involve the kind of inputs that don’t appear in normal unit/functional tests, as shown by the success of fuzzing and security audits. Fuzzing is not a replacement for functional/unit tests, and functional/unit tests are not a replacement for fuzzing too.</p>
<h2 id="conclusion-and-future-work">Conclusion and Future Work</h2>
<p>One conclusion is that the most effective way to improve fuzzing at present might be not to focus on covering the code and state space, but to focus on increasing the oracle power of all Bitcoin Core testing. Arguably, the greatest weakness of traditional code coverage is that it focuses too much attention on the input side of testing and too little on the oracle side, which is easier for even dedicated testing efforts to neglect in the pursuit of covering every branch and path.</p>
<p>Bitcoin Core is a open source software, which means everyone can contribute to its fuzzing infrastructure. Luckily, I got selected as one of the 83 students that will participate in <a href="https://blog.summerofbitcoin.org/summer-of-bitcoin-2022/" target="_blank">Summer of Bitcoin 2022</a>. Under the guidance of <a href="https://github.com/MarcoFalke" target="_blank">MarcoFalke</a>, I will add a specific fuzz target for orphan transaction handling, which was the source of several DoS attack vectors in the past. By contributing to Bitcoin Core, I can learn a lot about  transaction relay in the Bitcoin P2P network and hopefully find potential security issues in the code.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Marco Falke and all the other Bitcoin developers for their excellent demonstration of open source collaboration, which was the basis for my research into the evolution of Bitcoin development.</p>
<p>Thanks to the Summer of Bitcoin event organizing committee and sponsors like Chaincode Labs for guiding and supporting students in bitcoin development.</p>
<p>Thanks to Professor Alex Groce of Northern Arizona University for his contributions to software security analysis and fuzzing. His papers and blogs are really informative and lively.</p>
<h2 id="reference">Reference</h2>
<p>Groce, Alex, and Kush Jain. 2022. “Looking for Lacunae in Bitcoin Core’s
Fuzzing Efforts.” <em>International Conference on Software Engineering</em>, 2.</p>
<p>“Bug Disclosure Guidelines.” n.d. <em>OSS-Fuzz</em>.
<a href="https://google.github.io/oss-fuzz/getting-started/bug-disclosure-guidelines/">https://google.github.io/oss-fuzz/getting-started/bug-disclosure-guidelines/</a>.</p>
<p>Chen, Yuanliang, Yu Jiang, Fuchen Ma, Jie Liang, Mingzhe Wang, Chijin
Zhou, Xun Jiao, and Zhuo Su. 2019a. “EnFuzz: Ensemble Fuzzing with Seed
Synchronization Among Diverse Fuzzers.” In <em>USENIX Security Symposium</em>.</p>
<p>“EnFuzz: Ensemble Fuzzing with Seed Synchronization Among
Diverse Fuzzers.” In <em>28th USENIX Security Symposium (USENIX Security
19)</em>, 1967–83. Santa Clara, CA: USENIX Association.
<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/chen-yuanliang">https://www.usenix.org/conference/usenixsecurity19/presentation/chen-yuanliang</a>.</p>
<p>“ClusterFuzz.” n.d. <em>ClusterFuzz</em>.
<a href="https://google.github.io/clusterfuzz/">https://google.github.io/clusterfuzz/</a>.</p>
<p>“CVE-2012-3789.” n.d. <em>CVE-2012-3789 - Bitcoin Wiki</em>.
<a href="https://en.bitcoin.it/wiki/CVE-2012-3789">https://en.bitcoin.it/wiki/CVE-2012-3789</a>.</p>
<p>Dietterichl, Thomas G. 2002. “Ensemble Learning.” In <em>The Handbook of
Brain Theory and Neural Networks</em>, edited by M. Arbib, 405–8. MIT Press.</p>
<p>Fioraldi, Andrea, Dominik Maier, Heiko Eißfeldt, and Marc Heuse. 2020.
“{AFL++}: Combining Incremental Steps of Fuzzing Research.” In <em>14th
USENIX Workshop on Offensive Technologies (WOOT 20)</em>.</p>
<p>Garay, Juan, Aggelos Kiayias, and Nikos Leonardos. 2015. “The Bitcoin
Backbone Protocol: Analysis and Applications.” In <em>Annual International
Conference on the Theory and Applications of Cryptographic Techniques</em>,
281–310. Springer.</p>
<p>Google, Project Zero team at. 2015. <em>Feedback and Data-Driven Updates to
Google’s Disclosure Policy</em>.
<a href="https://googleprojectzero.blogspot.com/2015/02/feedback-and-data-driven-updates-to.html">https://googleprojectzero.blogspot.com/2015/02/feedback-and-data-driven-updates-to.html</a>.</p>
<p>Groce, Alex, Chaoqiang Zhang, Mohammad Amin Alipour, Eric Eide, Yang
Chen, and John Regehr. 2013. “Help, Help, i’m Being Suppressed! The
Significance of Suppressors in Software Testing.” In <em>2013 IEEE 24th
International Symposium on Software Reliability Engineering (ISSRE)</em>,
390–99. <a href="https://doi.org/10.1109/ISSRE.2013.6698892">https://doi.org/10.1109/ISSRE.2013.6698892</a>.</p>
<p>Groce, Alex, Chaoqiang Zhang, Eric Eide, Yang Chen, and John Regehr.
2012. “Swarm Testing.” In <em>Proceedings of the 2012 International
Symposium on Software Testing and Analysis</em>, 78–88. ISSTA 2012. New
York, NY, USA: Association for Computing Machinery.
<a href="https://doi.org/10.1145/2338965.2336763">https://doi.org/10.1145/2338965.2336763</a>.</p>
<p>Groce, Posted byAlex. 2021. “Oracles and Mutation Testing: Adding Bugs
to Code for Fun and Profit.” <em>How to Test It</em>.
<a href="https://howtotestit.wordpress.com/2021/03/31/oracles-and-mutation-testing-adding-bugs-to-code-for-fun-and-profit/">https://howtotestit.wordpress.com/2021/03/31/oracles-and-mutation-testing-adding-bugs-to-code-for-fun-and-profit/</a>.</p>
<p>“Honggfuzz.” n.d. <em>Honggfuzz</em>. <a href="https://honggfuzz.dev/">https://honggfuzz.dev/</a>.</p>
<p>Imtiaz, Muhammad Anas, David Starobinski, and Ari Trachtenberg. 2020.
“Characterizing Orphan Transactions in the Bitcoin Network.” In <em>2020
IEEE International Conference on Blockchain and Cryptocurrency (ICBC)</em>,
1–9.</p>
<p>Nakamoto, Satoshi. 2008. “Bitcoin Whitepaper.” <em>URL: Https://Bitcoin.
Org/Bitcoin. Pdf-(: 17.07. 2019)</em>.</p>
<p>“Oss-Fuzz: Five Months Later, and Rewarding Projects.” n.d. <em>Google Open
Source Blog</em>.
<a href="https://opensource.googleblog.com/2017/05/oss-fuzz-five-months-later-and.html">https://opensource.googleblog.com/2017/05/oss-fuzz-five-months-later-and.html</a>.</p>
<p>Papadakis, Mike, Marinos Kintis, Jie Zhang, Yue Jia, Yves Le Traon, and
Mark Harman. 2019. “Chapter Six - Mutation Testing Advances: An Analysis
and Survey.” In, edited by Atif M. Memon, 112:275–378. Advances in
Computers. Elsevier.
<a href="https://doi.org/">https://doi.org/</a><a href="https://doi.org/10.1016/bs.adcom.2018.03.015">https://doi.org/10.1016/bs.adcom.2018.03.015</a>.</p>
<p>Regehr, John. n.d. <em>The Saturation Effect in Fuzzing</em>.
<a href="https://blog.regehr.org/archives/1796">https://blog.regehr.org/archives/1796</a>.</p>
<p>Serebryany, Kosta. 2016. “Continuous Fuzzing with Libfuzzer and
Addresssanitizer.” In <em>2016 IEEE Cybersecurity Development (SecDev)</em>,
157–57. IEEE.</p>
<p>Serebryany, Kostya. 2017. “OSS-Fuzz - Google’s Continuous Fuzzing
Service for Open Source Software.” Vancouver, BC: USENIX Association.</p>
<p>Sompolinsky, Yonatan, and Aviv Zohar. 2016. “Bitcoin’s Security Model
Revisited.” <em>arXiv Preprint arXiv:1605.09193</em>.</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chinggg</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        <span title="2022-06-01 09:32:34 &#43;0800 &#43;0800">2022-06-01</span>
        <a href="https://github.com/chinggg/hugo-blog/commit/2b7adaa9e7f72ce072e1350566595b025363d760" title="Update Bitcoin-Fuzz" target="_blank">(2b7adaa)</a>
        ，<a href="https://github.com/chinggg/hugo-blog/commits/master/content/post/Bitcoin-Fuzz.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/paper/">Paper</a>
          <a href="/tags/bitcoin/">Bitcoin</a>
          <a href="/tags/fuzzing/">Fuzzing</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/summer-of-bitcoin/">
            <span class="next-text nav-default">My Experience in Summer of Bitcoin 2022</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
  <div class="comments">
    <div class="loading post">
      <img src="/img/spinner.svg">
      <p class="post-content">
        评论正在加载中...如果评论较长时间无法加载，你可以
        <a href='https://github.com/chinggg/chinggg.github.io/issues?q=is%3Aissue+is%3Aopen+"Fuzzing%20Evolution%3a%20How%20developers%20make%20Bitcoin%20more%20secure - chinggg%e7%9a%84%e5%8d%9a%e5%ae%a2"' target="_blank">搜索对应的 issue</a>
        或者
        <a href="https://github.com/chinggg/chinggg.github.io/issues/new?title=Fuzzing%20Evolution%3a%20How%20developers%20make%20Bitcoin%20more%20secure - chinggg%e7%9a%84%e5%8d%9a%e5%ae%a2" target="_blank">新建一个 issue</a>
        。
      </p>
    </div>
    <script src="https://utteranc.es/client.js"
            repo="chinggg/chinggg.github.io"
            issue-term="title"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>请启用 JavaScript 来查看评论。</a></noscript>
  </div>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:liuchinggg@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/chinggg" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://chinggg.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018 - 
    2022
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/chinggg/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">chinggg</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10/build/highlight.min.js"></script>
  <link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10/build/styles/tomorrow.min.css" rel="stylesheet"/>
  <script>hljs.configure({tabReplace: '    '});</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/slideout@1/dist/slideout.min.js" crossorigin="anonymous"></script>






<script type="text/javascript" src="/js/main.min.959fe0c07c3b2fcb923fb17e40bdcbf406ad5c8b8543391a2abc1728f469d080.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-215618742-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
