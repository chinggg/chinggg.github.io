<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向 on chinggg的博客</title><link>https://chinggg.github.io/tags/%E9%80%86%E5%90%91/</link><description>Recent content in 逆向 on chinggg的博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 25 Jan 2022 11:30:09 +0800</lastBuildDate><atom:link href="https://chinggg.github.io/tags/%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC Protobuf 逆向初探</title><link>https://chinggg.github.io/post/grpc-protobuf/</link><pubDate>Tue, 25 Jan 2022 11:30:09 +0800</pubDate><guid>https://chinggg.github.io/post/grpc-protobuf/</guid><description>逆向时开始见到 gRPC 协议和 Protobuf 编码在私信、直播等领域使用，故记录之。 gRPC 是基于 HTTP/2.0 来传输的，但 Fiddler 5 似乎尚不支持，在抓包某 App 时发现了神奇的现象，同样的功</description></item><item><title>验证码实战</title><link>https://chinggg.github.io/post/captcha/</link><pubDate>Fri, 24 Dec 2021 16:27:26 +0800</pubDate><guid>https://chinggg.github.io/post/captcha/</guid><description>&lt;h3 id="字符型验证码">字符型验证码&lt;/h3>
&lt;p>&lt;a href="https://www.jianshu.com/p/cefab352aa54" target="_blank">SimGAN-Captcha代码阅读与复现&lt;/a>
&lt;a href="https://blog.csdn.net/xinew4712/article/details/89396601" target="_blank">关于SimGAN-Captcha的扩展实验&lt;/a>
&lt;a href="https://zhuanlan.zhihu.com/p/54316183" target="_blank">全都得死：GAN掉字符验证码&lt;/a>&lt;/p>
&lt;h3 id="小试牛刀">小试牛刀&lt;/h3>
&lt;p>先尝试模拟，使用 &lt;a href="https://juejin.cn/post/6956800708389634079" target="_blank">puppteer&lt;/a> 稍加计算就能成功绕过极验&lt;/p>
&lt;p>请求依次为&lt;/p>
&lt;ul>
&lt;li>POST &lt;a href="https://passport.bilibili.com/x/passport-login/sms/send">https://passport.bilibili.com/x/passport-login/sms/send&lt;/a> 设备信息为 body，返回 recaptcha_url 随即向其发起请求，注意该 url 中的 gt 和 challenge 将用于后续一系列请求&lt;/li>
&lt;li>GET &lt;a href="https://www.bilibili.com/h5/project-msg-auth/verify?ct=geetest&amp;amp;recaptcha_token=&amp;amp;gee_gt=&amp;amp;gee_challenge=&amp;amp;hash=">https://www.bilibili.com/h5/project-msg-auth/verify?ct=geetest&amp;amp;recaptcha_token=&amp;amp;gee_gt=&amp;amp;gee_challenge=&amp;amp;hash=&lt;/a> 即向之前获得的 recaptcha_url 发送 GET 请求跳转到页面&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/gettype.php?gt=&amp;amp;callback=geetest_%7B13%E4%BD%8D%E6%AF%AB%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%7D">https://api.geetest.com/gettype.php?gt=&amp;amp;callback=geetest_{13位毫秒时间戳}&lt;/a> 返回一些配置参数如静态js文件的位置（即相对路径）&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/get.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=%7B%E4%B8%80%E9%95%BF%E4%B8%B2%7D&amp;amp;callback=">https://api.geetest.com/get.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w={一长串}&amp;amp;callback=&lt;/a> 仍然返回一些配置如验证开始前显示的i18n字符串&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=">https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=&lt;/a> 第一次请求 ajax.php，返回 &lt;code>callback值({&amp;quot;status&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;data&amp;quot;: {&amp;quot;result&amp;quot;: &amp;quot;slide&amp;quot;}})&lt;/code>&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/get.php">https://api.geetest.com/get.php&lt;/a> 此时刚加载了 slide.js，和第一次请求 get.php 相比多了一些 params 如 &lt;code>is_next=true&amp;amp;type=slide3&lt;/code>，返回结果中有滑块验证时会显示的i18n字符串，以及&lt;strong>滑块和图片的位置&lt;/strong>&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;%24_BBF=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=">https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;%24_BBF=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=&lt;/a> 最终的请求，返回 success 及 score&lt;/li>
&lt;/ul>
&lt;h3 id="工程化探索">工程化探索&lt;/h3>
&lt;p>将验证码填充作为通用服务运行，让爬虫客户端无感绕过验证码，考虑在客户端和服务端（比如 puppeteer）之间使用 RPC，客户端先调起服务端，服务端进入验证码流程，但将所有请求拦截并通过 RPC 传递给客户端，客户端代为请求，响应结果作为 RPC 的返回值，服务端再强行将其作为响应，继续之后的动作，从而在验证方看来客户端正常完成了验证。&lt;/p>
&lt;p>真正开发过程中，很多时间浪费在了数据类型造成的错误中，在 proto 中我把除状态码外的所有字段定为 string，但用 axios 等库发起请求时，header 为 object，且若不在请求时指定 responseType，所获响应默认用 json 解析成 object，否则才是 text。更坑的是图片等二进制数据，获得为文本时已经铸成大错，需要先指定 responseType 为 &lt;code>arraybuffer&lt;/code>（在 Node 中 &lt;code>blob&lt;/code> 实际还是以文本返回，因为 &lt;code>blob&lt;/code> 是 browser only），然后 &lt;code>res.data.toString('base64')&lt;/code> 转成 base64 字符串通过 RPC 传递，接收方再 &lt;code>Buffer.from(str, 'base64')&lt;/code> 来转成 buffer。&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/6844904182114189320" target="_blank">JS逆向：AST还原极验混淆JS实战&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/virjar/geeEtacsufbo" target="_blank">反符号混淆和控制流平坦化&lt;/a>&lt;/p></description></item><item><title>AppRE</title><link>https://chinggg.github.io/post/appre/</link><pubDate>Tue, 30 Nov 2021 14:36:28 +0800</pubDate><guid>https://chinggg.github.io/post/appre/</guid><description>App 逆向基础 国产应用大多热衷于构筑自己的 App 围墙，很多功能没有网页版，也就无法利用浏览器一探究竟，不过我们仍然可以通过抓包、静态分析、动态调试的</description></item><item><title>Android Hook</title><link>https://chinggg.github.io/post/android-hook/</link><pubDate>Wed, 17 Nov 2021 16:38:08 +0800</pubDate><guid>https://chinggg.github.io/post/android-hook/</guid><description>Frida 万金油动态调试工具，配合自己收集定制的 hook 模板代码，稍作修改就可以快速查看 Java 层的类及其方法成员信息和 Native 层函数的参数与返回值，便于验证自己的想</description></item><item><title>FART</title><link>https://chinggg.github.io/post/fart/</link><pubDate>Fri, 05 Nov 2021 23:04:43 +0800</pubDate><guid>https://chinggg.github.io/post/fart/</guid><description>安卓脱壳 FART 速成 环境准备 Pixel 3a XL 一台，代号 bonito，先恢复出厂系统 ，再准备相应源码， android-9.0.0_r47 对应 版本号 PQ3B.190801.002 对应，android-10.0.0_r2 对</description></item></channel></rss>