<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>安全 on chinggg的博客</title><link>https://chinggg.github.io/categories/%E5%AE%89%E5%85%A8/</link><description>Recent content in 安全 on chinggg的博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 07 Jan 2022 20:57:24 +0800</lastBuildDate><atom:link href="https://chinggg.github.io/categories/%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>SEEDLab Network</title><link>https://chinggg.github.io/post/seed-network/</link><pubDate>Fri, 07 Jan 2022 20:57:24 +0800</pubDate><guid>https://chinggg.github.io/post/seed-network/</guid><description>&lt;h1 id="seed-labs-20---network-securityhttpsseedsecuritylabsorglabs_2004networking">&lt;a href="https://seedsecuritylabs.org/Labs_20.04/Networking/" target="_blank">SEED Labs 2.0 - Network Security&lt;/a>&lt;/h1>
&lt;h2 id="firewallhttpsseedsecuritylabsorglabs_2004filesfirewallfirewallpdf">&lt;a href="https://seedsecuritylabs.org/Labs_20.04/Files/Firewall/Firewall.pdf" target="_blank">Firewall&lt;/a>&lt;/h2>
&lt;h3 id="使用-netfilter-自制防火墙-lkm">使用 NetFilter 自制防火墙 LKM&lt;/h3>
&lt;p>Netfilter 是 Linux 内核中一个用于管理网络数据包的软件框架，可以使用它自制 Linux Kernel Module，实现简易的防火墙。&lt;/p>
&lt;p>Task1 只是练习如何编译内核模块，即在 &lt;code>module_init(fn)&lt;/code>, &lt;code>module_exit(fn)&lt;/code> 处初始化及退出。&lt;/p>
&lt;p>使用 Netfilter 搭建防火墙的步骤：&lt;/p>
&lt;ul>
&lt;li>定义 nf_hook_ops 结构体，给 hook(hook函数) 和 hooknum(hook点类型) 赋值&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">struct nf_hook_ops {
/* User fills in from here down. */
nf_hookfn *hook;
struct net_device *dev;
void *priv;
u8 pf;
enum nf_hook_ops_type hook_ops_type:8;
unsigned int hooknum;
/* Hooks are ordered in ascending priority. */
int priority;
};
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>模块加载时 &lt;code>nf_register_net_hook(&amp;amp;init_net, &amp;amp;hook1)&lt;/code>，卸载时 &lt;code>nf_unregister_net_hook(&amp;amp;init_net, &amp;amp;hook1)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nf_hookfn&lt;/code> 函数签名如下，实验中只需 &lt;code>ip_hdr(skb)&lt;/code> 获得 iphdr 结构体（类似有 tcphdr/udphdr），再从 iph 获得协议类型、源/目标地址，从 tcph/udph 获得端口号，比较决定是否 DROP 即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">typedef unsigned int nf_hookfn(void *priv,
struct sk_buff *skb,
const struct nf_hook_state *state);
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>注意每个结构体只能赋值一个 &lt;code>hooknum&lt;/code>，想在多个点上 hook 需定义多个 &lt;code>nf_hook_ops&lt;/code>，分别设置不同的 hooknum，枚举类型如下：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-c">enum nf_inet_hooks {
NF_INET_PRE_ROUTING,
NF_INET_LOCAL_IN,
NF_INET_FORWARD,
NF_INET_LOCAL_OUT,
NF_INET_POST_ROUTING,
NF_INET_NUMHOOKS,
NF_INET_INGRESS = NF_INET_NUMHOOKS,
};
&lt;/code>&lt;/pre>
&lt;h3 id="使用-iptables">使用 iptables&lt;/h3>
&lt;p>基本命令 &lt;code>iptables -A {chain} -j {rule}&lt;/code>，&lt;code>-i/o {dev}&lt;/code> 指定入/出接口，&lt;code>-s/d&lt;/code> 指定源/目标地址，&lt;code>-sport/dport&lt;/code> 指定源/目标端口&lt;/p>
&lt;p>对于 TCP 连接，使用 &lt;code>conntrack&lt;/code> 模块搭建有状态防火墙，只允许已经建立的 TCP 连接和内部发起新连接&lt;/p>
&lt;p>限流使用 &lt;code>limit&lt;/code> 模块，&lt;code>--limit&lt;/code> 指定设置最大频率（即如10次/分钟），&lt;code>--limit-burst&lt;/code> 指定最大连续次数&lt;/p>
&lt;p>负载均衡使用 &lt;code>statistic&lt;/code> 模块，&lt;code>--mode&lt;/code> 指定模式为 &lt;code>random&lt;/code> 或 &lt;code>nth&lt;/code>，&lt;code>random&lt;/code> 模式下 &lt;code>--probability&lt;/code> 指定概率，&lt;code>nth&lt;/code> 模式下 &lt;code>--every n&lt;/code> 指定轮转周期，&lt;code>--packet p&lt;/code> 指定初始计数值（即从[0,n-1]中某处开始计数），一般配合 &lt;code>-j DNAT --to-destination {ip:port}&lt;/code> 使用&lt;/p>
&lt;h2 id="vpn_tunnelhttpsseedsecuritylabsorglabs_2004filesvpn_tunnelvpn_tunnelpdf">&lt;a href="https://seedsecuritylabs.org/Labs_20.04/Files/VPN_Tunnel/VPN_Tunnel.pdf" target="_blank">VPN_Tunnel&lt;/a>&lt;/h2>
&lt;p>实验基于 &lt;a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html" target="_blank">TUN/TAP&lt;/a> 技术，TUN 模拟网络层设备，TAP 模拟数据链路层设备，用户程序和操作系统可以通过 TUN/TAP 接口互相传递数据包。&lt;/p>
&lt;pre>&lt;code>Client Program send(ip) -&amp;gt;
Client TUN read(ip) -&amp;gt;
Client Socket send(udp/ip) -&amp;gt;
Server Socket recv(udp/ip) -&amp;gt;
Server TUN write(ip) -&amp;gt;
...
route to dst then got reply routed back
...
Server TUN read(ip) -&amp;gt;
Server Socket send(udp/ip) -&amp;gt;
Client Socket recv(udp/ip) -&amp;gt;
Client TUN write(ip) -&amp;gt;
Client Program recv(ip)
&lt;/code>&lt;/pre>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/">https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>验证码实战</title><link>https://chinggg.github.io/post/captcha/</link><pubDate>Fri, 24 Dec 2021 16:27:26 +0800</pubDate><guid>https://chinggg.github.io/post/captcha/</guid><description>&lt;h3 id="小试牛刀">小试牛刀&lt;/h3>
&lt;p>先尝试模拟，使用 &lt;a href="https://juejin.cn/post/6956800708389634079" target="_blank">puppteer&lt;/a> 稍加计算就能成功绕过极验&lt;/p>
&lt;p>请求依次为&lt;/p>
&lt;ul>
&lt;li>POST &lt;a href="https://passport.bilibili.com/x/passport-login/sms/send">https://passport.bilibili.com/x/passport-login/sms/send&lt;/a> 设备信息为 body，返回 recaptcha_url 随即向其发起请求，注意该 url 中的 gt 和 challenge 将用于后续一系列请求&lt;/li>
&lt;li>GET &lt;a href="https://www.bilibili.com/h5/project-msg-auth/verify?ct=geetest&amp;amp;recaptcha_token=&amp;amp;gee_gt=&amp;amp;gee_challenge=&amp;amp;hash=">https://www.bilibili.com/h5/project-msg-auth/verify?ct=geetest&amp;amp;recaptcha_token=&amp;amp;gee_gt=&amp;amp;gee_challenge=&amp;amp;hash=&lt;/a> 即向之前获得的 recaptcha_url 发送 GET 请求跳转到页面&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/gettype.php?gt=&amp;amp;callback=geetest_%7B13%E4%BD%8D%E6%AF%AB%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%7D">https://api.geetest.com/gettype.php?gt=&amp;amp;callback=geetest_{13位毫秒时间戳}&lt;/a> 返回一些配置参数如静态js文件的位置（即相对路径）&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/get.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=%7B%E4%B8%80%E9%95%BF%E4%B8%B2%7D&amp;amp;callback=">https://api.geetest.com/get.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w={一长串}&amp;amp;callback=&lt;/a> 仍然返回一些配置如验证开始前显示的i18n字符串&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=">https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;pt=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=&lt;/a> 第一次请求 ajax.php，返回 &lt;code>callback值({&amp;quot;status&amp;quot;: &amp;quot;success&amp;quot;, &amp;quot;data&amp;quot;: {&amp;quot;result&amp;quot;: &amp;quot;slide&amp;quot;}})&lt;/code>&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/get.php">https://api.geetest.com/get.php&lt;/a> 此时刚加载了 slide.js，和第一次请求 get.php 相比多了一些 params 如 &lt;code>is_next=true&amp;amp;type=slide3&lt;/code>，返回结果中有滑块验证时会显示的i18n字符串，以及&lt;strong>滑块和图片的位置&lt;/strong>&lt;/li>
&lt;li>GET &lt;a href="https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;%24_BBF=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=">https://api.geetest.com/ajax.php?gt=&amp;amp;challenge=&amp;amp;lang=zh-cn&amp;amp;%24_BBF=3&amp;amp;client_type=web_mobile&amp;amp;w=&amp;amp;callback=&lt;/a> 最终的请求，返回 success 及 score&lt;/li>
&lt;/ul>
&lt;h3 id="工程化探索">工程化探索&lt;/h3>
&lt;p>将验证码填充作为通用服务运行，让爬虫客户端无感绕过验证码，考虑在客户端和服务端（比如 puppeteer）之间使用 RPC，客户端先调起服务端，服务端进入验证码流程，但将所有请求拦截并通过 RPC 传递给客户端，客户端代为请求，响应结果作为 RPC 的返回值，服务端再强行将其作为响应，继续之后的动作，从而在验证方看来客户端正常完成了验证。&lt;/p>
&lt;p>真正开发过程中，很多时间浪费在了数据类型造成的错误中，在 proto 中我把除状态码外的所有字段定为 string，但用 axios 等库发起请求时，header 为 object，且若不在请求时指定 responseType，所获响应默认用 json 解析成 object，否则才是 text。更坑的是图片等二进制数据，获得为文本时已经铸成大错，需要先指定 responseType 为 &lt;code>arraybuffer&lt;/code>（在 Node 中 &lt;code>blob&lt;/code> 实际还是以文本返回，因为 &lt;code>blob&lt;/code> 是 browser only），然后 &lt;code>res.data.toString('base64')&lt;/code> 转成 base64 字符串通过 RPC 传递，接收方再 &lt;code>Buffer.from(str, 'base64')&lt;/code> 来转成 buffer。&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/6844904182114189320" target="_blank">JS逆向：AST还原极验混淆JS实战&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/virjar/geeEtacsufbo" target="_blank">反符号混淆和控制流平坦化&lt;/a>&lt;/p></description></item><item><title>AppRE</title><link>https://chinggg.github.io/post/appre/</link><pubDate>Tue, 30 Nov 2021 14:36:28 +0800</pubDate><guid>https://chinggg.github.io/post/appre/</guid><description>&lt;h2 id="app-逆向基础">App 逆向基础&lt;/h2>
&lt;p>国产应用大多热衷于构筑自己的 App 围墙，很多功能没有网页版，也就无法利用浏览器一探究竟，不过我们仍然可以通过抓包、静态分析、动态调试的方法解开隐藏在 App 中的秘密。&lt;/p>
&lt;p>抓包能让我们快速获得想要的 API，不过其门槛也在不断增高，Android 7.0 之后应用不再相信非系统证书，客户端应用也可能使用 SSL Pinning 等技术防止中间人的干扰，一般用 Xposed 模块 JustTrustMe 或 TrustMeAlready 可以解决，某些关键请求可能还需额外 hook，可以为其专门定制 Xposed 模块。&lt;/p>
&lt;p>抓包获得关键请求后，分析其字段的意义，并在静态分析工具中全局搜索，定位至相关函数，应用大多会将数据编码、加密或生成摘要，这些逻辑可能放在 native 层实现，增大了逆向的难度。&lt;/p>
&lt;p>所幸 frida 等工具的出现大大便利了动态调试，可以方便地 hook 得到 Java 层各个类及其成员、方法，对于 native 层，也可在获得函数的参数和返回值，快速验证逆向分析时的想法。若由于时机等原因难以 hook，还可直接将 so 库封装到自己创建的 app 中，在 &lt;code>build.gradle&lt;/code> 里添加 abiFilters 参数以指定 arm 指令集，手动复制关键类并 import，再在 MainActivity 里 loadLibrary，即可直接调用 native 层方法，调试并在断点之间 hook 更改 context 寄存器的值，查看变量的值。&lt;/p>
&lt;p>逆向得到加密数据、生成校验的算法后，便可以伪造合法的请求。编码上的细节需要多加考虑，抓包得到 params 或 body 中的参数大都是 urlencode 后的结果，但生成校验时的参数却可能是原始的字符串，构造请求时要头脑清醒。排查错误时要冷静，关键位置往往是正确的，但完全没料到的地方可能出岔子，比如谁能想到 f-string 中嵌入 bytes 型的参数，不会报错，生成的字符串里居然还带着引号，而且作为 body 发送居然看上去一模一样？&lt;/p>
&lt;pre>&lt;code class="language-python">bstr = b'feiwu'
fstr = f'woshi {bstr}'
print(fstr)
# woshi b'feiwu'
&lt;/code>&lt;/pre>
&lt;p>不能以脚本小子的心态写脚本，必须做好代码的类型标注，模块化编程，这样即使无法避免问题的发生，也能在问题出现时快速定位。排查问题时脑子注意转过弯来，如果加密算法中有随机值，先固定下来，在静态的层面上观察结果，与真实样本做对比。&lt;/p>
&lt;h2 id="实战案例复盘">实战案例复盘&lt;/h2>
&lt;p>&lt;a href="https://www.qinless.com/341" target="_blank">某品会 edata 参数(AES 加密)&lt;/a>&lt;/p>
&lt;p>仅有少量请求有 edata 参数，从一串 query params 型的键值对字符串，得到 AES 加密并 base64 编码后的 edata 结果，具体实现在 esNav 这个 native 函数中。&lt;/p>
&lt;p>首先静态分析，IDA 反编译后两百多行，一上来就从全局变量中获取了未知的字符串，然后放入不知所云的 &lt;code>gsigds&lt;/code> 函数中进行一通操作。此时盲目扎进细节中耗时耗力而且白费功夫，只需抓住 AES 加密的核心，无非是 key 和 iv，倒过来分析代码发现前者是 md5 后的值，后者是随机的16位 hex 字符串，生成 edata 的前十六位字符便是 iv，后面再拼接 AES 加密的结果，这样服务器获得发送过来的 edata 后即可对称解密，而 key 显然应该是每次固定的，所以只需 hook 生成 md5 的函数获得返回值，便能得到 key 进而实现加密算法。&lt;/p>
&lt;p>但在测试手机上发现该应用在运行时 hook 容易崩溃，只能以 spawn 的形式 hook， 而抓包发现 edata 的请求似乎只在初始化时发送，刚启动时 native 层中的关键函数又尚未被加载，很难有合适的时机 hook，这时就可以自制 App 直接调用 Java 层函数，在断点之间 hook 即可拿到 key。&lt;/p>
&lt;p>&lt;a href="https://www.qinless.com/139" target="_blank">某品会 api_sign 验证头(SHA1 摘要)&lt;/a>&lt;/p>
&lt;p>每一个请求头都会带上 &lt;code>Authorization: OAuth api_sign={}&lt;/code>，全局搜索定位到 native 函数 gsNav，是从 &lt;code>TreeMap&amp;lt;String, String&amp;gt;&lt;/code>(也就是 query params) 得到一串 SHA1 摘要。&lt;/p>
&lt;p>进 IDA 分析，发现仍然调用了 &lt;code>gsigds&lt;/code> 函数获取字符串，传入 &lt;code>getByteHash&lt;/code> 获得了32位的 hex 字符串作为盐，拼接在从 Map 转成的 query param 型字符串前进行 SHA1 摘要，再对结果再来一次加盐摘要即得 api_sign，实际上如果熟悉 SHA1 的话看到 api_sign 是长为40的 hex 应该就能想到。&lt;/p>
&lt;pre>&lt;code class="language-python">import base6
import hashlib
import json
import random
from urllib.parse import unquote, parse_qsl, urlencode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
def gen_sign(paramstr: str) -&amp;gt; str:
&amp;quot;&amp;quot;&amp;quot;paramstr will unquoted automatically&amp;quot;&amp;quot;&amp;quot;
paramstr = unquote(paramstr).encode()
salt = b&amp;quot;da19a1b93059ff3609fc1ed2e04b0141&amp;quot; # True
salt = b&amp;quot;aee4c425dbb2288b80c71347cc37d04b&amp;quot; # False
h1 = hashlib.sha1(salt + paramstr)
cipher1 = h1.hexdigest().encode()
h2 = hashlib.sha1(salt + cipher1)
return h2.hexdigest()
def gen_edata(paramstr: str) -&amp;gt; str:
&amp;quot;&amp;quot;&amp;quot;paramstr: app_name=...&amp;amp;dinfo=...&amp;quot;&amp;quot;&amp;quot;
paramstr = paramstr.encode()
paramstr = pad(paramstr, 16)
key = bytearray.fromhex(&amp;quot;8c c7 03 f6 47 8e 58 f0 84 49 d5 c0 cf 2d d5 83&amp;quot;) # True
key = bytearray.fromhex(&amp;quot;cd d1 7a b2 9b 84 b3 25 52 dd cf bb 4a bf 02 25&amp;quot;) # False
key = bytes(key)
ran16b = ''.join(random.choices('0123456789abcdef', k=16)).encode()
cipher = AES.new(key, AES.MODE_CBC, iv=ran16b)
enctext = cipher.encrypt(paramstr)
ans = base64.b64encode(ran16b + enctext)
return ans.decode()
def dec_edata(b64s: str) -&amp;gt; str:
enctext = base64.b64decode(b64s.encode())
key = bytearray.fromhex(&amp;quot;8c c7 03 f6 47 8e 58 f0 84 49 d5 c0 cf 2d d5 83&amp;quot;) # True
key = bytearray.fromhex(&amp;quot;cd d1 7a b2 9b 84 b3 25 52 dd cf bb 4a bf 02 25&amp;quot;) # False
key = bytes(key)
iv = enctext[:16]
cipher = AES.new(key, AES.MODE_CBC, iv=iv)
raw = cipher.decrypt(enctext[16:])
try:
return raw.decode()
except:
return raw
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://www.qinless.com/745" target="_blank">某物 app so newSign 参数分析&lt;/a>&lt;/p>
&lt;p>常规抓包只能看见小部分请求，检索 &lt;code>NO_PROXY&lt;/code>，发现 okhttp3.OkHttpClient$Builder.proxy 处可以 hook，果然 hook 后才可抓到关键请求如 &lt;code>/api/v1/app/search/ice/search/list&lt;/code>，检索该 URL 果然在 &lt;code>com.XXX.common.base.delegate.tasks.net.ApiConfigCons&lt;/code> 中发现了 &lt;code>BLACK_LIST&lt;/code> 这一个黑名单集合。&lt;/p>
&lt;p>搜索请求中的 newSign 字段，发现 &lt;code>WebRequestInterceptor.intercept&lt;/code> 会给请求附上 newSign， 其值为 &lt;code>RequestUtils.c(hashMap, timestamp)&lt;/code> 的结果，c 这个方法就是在 map 中再补充一些键值对，然后生成按字典序拼接 kv 得到的字符串，传进 &lt;code>AESEncrypt.encode(context, str)&lt;/code> 方法，返回值再套一层 f 方法（即 md5）即为最终的 newSign。关键是 &lt;code>AESEncrypt.encode&lt;/code> 这个方法里调了 &lt;code>NCall.IL()&lt;/code> 这个 Native 函数，然而在 &lt;code>libGameVMP.so&lt;/code> 中却无法继续跟踪，用 frida dump 出的 so 不再显示格式错误，但仍然找不到 IL 这个函数。&lt;/p>
&lt;p>&lt;a href="https://www.hiczp.com/wang-luo/mo-ni-bilibili-android-ke-hu-duan-deng-lu.html" target="_blank">模拟 Bili Android 客户端&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://events.jianshu.io/p/d240ded1d44f" target="_blank">YmlsaWJpbGk= app分析&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_38851536/article/details/114238361" target="_blank">Native逆向指北(一)——BiliBili Sign&lt;/a>&lt;/p>
&lt;p>&lt;code>com.bilibili.lib.accounts.BiliAuthService&lt;/code> 列出了登录相关 API，&lt;code>com.bilibili.lib.accounts.a implements com.bilibili.okretro.interceptor.DefaultRequestInterceptor&lt;/code> 会给这些请求 &lt;code>addCommonParam&lt;/code>，并在最后附加 sign(&lt;code>[0-9a-f]{32}&lt;/code>)&lt;/p>
&lt;pre>&lt;code class="language-java">map.put(&amp;quot;platform&amp;quot;, &amp;quot;android&amp;quot;);
map.put(&amp;quot;mobi_app&amp;quot;, BiliConfig.getMobiApp()); // &amp;quot;android&amp;quot;
map.put(RestUrlWrapper.FIELD_APPKEY, getAppKey()); // appkey: [0-9a-f]{16}
map.put(&amp;quot;build&amp;quot;, String.valueOf(BiliConfig.getBiliVersionCode())); // I() { return 6540300; }
map.put(&amp;quot;buvid&amp;quot;, AccountConfig.paramDelegate.getBuvid()); // ^XY[A-F0-9]{35}
map.put(&amp;quot;channel&amp;quot;, BiliConfig.getChannel()); // bili
map.put(&amp;quot;c_locale&amp;quot;, BiliConfig.getCurrentLocale());
map.put(&amp;quot;s_locale&amp;quot;, BiliConfig.getSystemLocale());
&lt;/code>&lt;/pre>
&lt;p>&lt;code>BiliConfig&lt;/code> 的方法追溯到内部类 &lt;code>public static class a implements b&lt;/code>，真正实现 &lt;code>interface b&lt;/code> 的是 &lt;code>tv.danmaku.bili.utils.p$a&lt;/code>&lt;/p>
&lt;p>其中 &lt;code>buvid&lt;/code> 跟到 &lt;code>com.bilibili.lib.blkv.internal.kv.KVs.getString(&amp;quot;buvid&amp;quot;, &amp;quot;&amp;quot;)&lt;/code>&lt;/p>
&lt;p>sign 的生成在 &lt;code>com.bilibili.nativelibrary.LibBili.signQuery(Map&amp;lt;String, String&amp;gt;)&lt;/code>，实际调用 native 函数 s，但其在 &lt;code>libbili.so&lt;/code> 中是动态注册的&lt;/p>
&lt;pre>&lt;code>[RegisterNatives] java_class: com.bilibili.nativelibrary.LibBili name: s sig: (Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery; fnPtr: 0xc13138e9 fnOffset: 0x68e9 callee: 0xc1313303 libbili.so!JNI_OnLoad+0x14e
&lt;/code>&lt;/pre>
&lt;h2 id="工程化模拟">工程化模拟&lt;/h2>
&lt;p>&lt;a href="https://bbs.nightteam.cn/forum.php?mod=viewthread&amp;amp;tid=1195" target="_blank">Android逆向之无加固下的Java层和Native层模拟的调度解决方案&lt;/a>&lt;/p></description></item><item><title>Android Hook</title><link>https://chinggg.github.io/post/android-hook/</link><pubDate>Wed, 17 Nov 2021 16:38:08 +0800</pubDate><guid>https://chinggg.github.io/post/android-hook/</guid><description>Frida 万金油动态调试工具，配合自己收集定制的 hook 模板代码，稍作修改就可以快速查看 Java 层的类及其方法成员信息和 Native 层函数的参数与返回值，便于验证自己的想</description></item><item><title>FART</title><link>https://chinggg.github.io/post/fart/</link><pubDate>Fri, 05 Nov 2021 23:04:43 +0800</pubDate><guid>https://chinggg.github.io/post/fart/</guid><description>安卓脱壳 FART 速成 环境准备 Pixel 3a XL 一台，代号 bonito，先恢复出厂系统 ，再准备相应源码， android-9.0.0_r47 对应 版本号 PQ3B.190801.002 对应，android-10.0.0_r2 对</description></item></channel></rss>